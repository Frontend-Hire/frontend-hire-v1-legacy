# Solution

## TDD Approach

In this question, we will follow the Test-Driven Development (TDD) approach to implement the `useHover` custom hook. We will write tests first and then implement the hook to make the tests pass.

## Writing Tests

Let us write tests for the `useHover` custom hook in the `useHover.test.ts` file.

### Test Cases

1. The hook should return `false` initially.
2. The hook should return `true` when the mouse enters the element.
3. The hook should return `false` when the mouse leaves the element.
4. The hook should clean up event listeners on unmount.
5. The hook should use the document as the default element and return `true` when the mouse enters the document.
6. The hook should use the document as the default element and return `false` when the mouse leaves the document.

```ts title="useHover.test.ts" showLineNumbers
import { renderHook, act } from "@testing-library/react";
import { describe, it, expect, vi, beforeEach } from "vitest";

// internal hook
import useHover from "./useHover";

describe("useHover on element ref", () => {
  beforeEach(() => {
    document.body.innerHTML = '<div id="test-element"></div>';
  });

  it("should return false initially", () => {
    const ref = { current: document.getElementById("test-element") };
    const { result } = renderHook(() => useHover(ref));
    expect(result.current).toBe(false);
  });

  it("should return true when mouse enters the element", () => {
    const ref = { current: document.getElementById("test-element") };
    const { result } = renderHook(() => useHover(ref));

    act(() => {
      ref.current?.dispatchEvent(new MouseEvent("mouseenter"));
    });

    expect(result.current).toBe(true);
  });

  it("should return false when mouse leaves the element", () => {
    const ref = { current: document.getElementById("test-element") };
    const { result } = renderHook(() => useHover(ref));

    act(() => {
      ref.current?.dispatchEvent(new MouseEvent("mouseenter"));
    });
    expect(result.current).toBe(true);

    act(() => {
      ref.current?.dispatchEvent(new MouseEvent("mouseleave"));
    });
    expect(result.current).toBe(false);
  });

  it("should clean up event listeners on unmount", () => {
    const ref = { current: document.getElementById("test-element") };
    const removeEventListenerSpy = vi.spyOn(
      ref.current!,
      "removeEventListener"
    );

    const { unmount } = renderHook(() => useHover(ref));
    unmount();

    expect(removeEventListenerSpy).toHaveBeenCalledTimes(2);
    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      "mouseenter",
      expect.any(Function)
    );
    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      "mouseleave",
      expect.any(Function)
    );
  });
});

describe("useHover on document ref", () => {
  it("should use document as default ref and return true when mouse enters the document", () => {
    const { result } = renderHook(() => useHover());

    act(() => {
      document.dispatchEvent(new MouseEvent("mouseenter"));
    });

    expect(result.current).toBe(true);
  });

  it("should use document as default ref and return false when mouse leaves the document", () => {
    const { result } = renderHook(() => useHover());

    act(() => {
      document.dispatchEvent(new MouseEvent("mouseenter"));
    });
    expect(result.current).toBe(true);

    act(() => {
      document.dispatchEvent(new MouseEvent("mouseleave"));
    });
    expect(result.current).toBe(false);
  });
});

```

### Fixing the code

Now, let us fix the code that causes the bugs. We will implement the `useHover` hook in the `useHover.ts` file.

```ts title="useHover.ts" showLineNumbers
import { useState, useEffect, RefObject } from "react";

function useHover<T extends HTMLElement = HTMLElement>(
  ref?: RefObject<T>
): boolean {
  const [isHovering, setIsHovering] = useState(false);

  useEffect(() => {
    const element = ref?.current || document;
    if (!element) return;

    const handleMouseEnter = () => setIsHovering(true);
    const handleMouseLeave = () => setIsHovering(false);

    element.addEventListener("mouseenter", handleMouseEnter);
    element.addEventListener("mouseleave", handleMouseLeave);

    return () => {
      element.removeEventListener("mouseenter", handleMouseEnter);
      element.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [ref]);

  return isHovering;
}

export default useHover;
```

### Verifying that the tests pass

Now, let us verify that the tests pass.

```bash
pnpm test
```

The tests should pass.

## Summary

In this question, we have successfully implemented the `useHover` custom hook and written tests for it. We have followed the TDD approach to fix the bugs in the hook.

---
