import { Callout } from '@/components/MarkdownComponents';

# Solution

TDD (test-driven development) shines in this type of scenario. We will also use the same approach here.

## Tests

Let us first write the tests for the following cases:

### The method returns `undefined` for an index that is out of the array's bounds

Handling this first helps handle edge cases early on.

```js title="index.test.js"
test('it returns undefined if index is out of bounds', () => {
  expect(arrayAt([1, 2, 3], 5)).toBe(undefined);

  expect(arrayAt([1, 2, 3], -5)).toBe(undefined);
});
```

This test should automatically pass since the method does not return anything at the moment.

### The method returns the correct item for a positive index

```js title="index.test.js"
test('it returns the element at the given positive index', () => {
  expect(arrayAt([1, 2, 3], 1)).toBe(2);

  expect(arrayAt([1, 2, 3], 2)).toBe(3);
});
```

### The method returns the correct item for a negative index

```js title="index.test.js"
test('it returns the element at the given negative index', () => {
  expect(arrayAt([1, 2, 3], -1)).toBe(3);

  expect(arrayAt([1, 2, 3], -2)).toBe(2);
});
```

Putting them all together:

```js title="index.test.js"
import { describe, test, expect } from 'vitest';

import { arrayAt } from './index';

describe('polyfill-array-at', () => {
  test('it returns undefined if index is out of bounds', () => {
    expect(arrayAt([1, 2, 3], 5)).toBe(undefined);

    expect(arrayAt([1, 2, 3], -5)).toBe(undefined);
  });

  test('it returns the element at the given positive index', () => {
    expect(arrayAt([1, 2, 3], 1)).toBe(2);

    expect(arrayAt([1, 2, 3], 2)).toBe(3);
  });

  test('it returns the element at the given negative index', () => {
    expect(arrayAt([1, 2, 3], -1)).toBe(3);

    expect(arrayAt([1, 2, 3], -2)).toBe(2);
  });
});
```

## The polyfill

So, what does the regular array accessing do?

```js
export function arrayAt(arr, index) {
  return arr[index];
}
```

This already passes the undefined and positive index tests.

The only issue is the negative index test. We need to do some extra work to make it work.

The logic is quite simple. We just have to recalculate the index based on the length of the array and the negative index but only when the index is negative. So, a simple if statement should do it.

![simple explanation](./polyfill-array-at.webp)

```js
export function arrayAt(arr, index) {
  if (index < 0) {
    return arr[arr.length + index];
  }

  return arr[index];
}
```